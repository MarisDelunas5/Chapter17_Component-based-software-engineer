<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Component-based software engineering</title>
    <link rel="stylesheet" href="17.3.css">
</head>
<body>

    
    <h1 class="title">COMPONENT POSITION</h1>

      <div class="class"><p>Component composition is the process of integrating components with each other, and
     with specially written ‘glue code’ to create a system or another component. There are
     several different ways in which you can compose components, as shown in Figure 17.10.
      From left to right these diagrams illustrate sequential composition, hierarchical composition and additive composition. In the discussion below, I assume that you are composing
     two components (A and B) to create a new component:</p>

    <p>1. Sequential composition is situation (a) in Figure 17.10. You create a new component from 2 existing components by calling the existing components in sequence.
You can think of the composition as a composition of the ‘provides interfaces’.
That is, the services offered by component A are called and the results returned
by A are then used in the call to the services offered by component B. The components do not call each other in sequential composition. Some extra glue code is
required to call the component services in the right order and to ensure that the
results delivered by component A are compatible with the inputs expected by
component B. The ‘provides’ interface of the composition depends on the combined functionality of A and B but will not normally be a composition of their
‘provides interfaces’. This type of composition may be used with components
that are program elements or components that are services.</p>
<p>2. Hierarchical composition is situation (b) in Figure 17.10. This type of composition occurs when one component calls directly on the services provided by
another component. The called component provides the services that are required
by the calling component. Therefore, the ‘provides’ interface of the called component must be compatible with the ‘requires’ interface of the calling component.
Component A calls on component B directly and, if their interfaces match, there
may be no need for additional code. However, if there is a mismatch between the
‘requires’ interface of A and the ‘provides’ interface of B, then some conversion
code may be required. As services do not have a ‘requires’ interface, this mode of
composition is not used when components are implemented as web services.</p>
<p>3. Additive composition corresponds to situation (c) in Figure 17.10. This occurs
when two or more components are put together (added) to create a new component,</p>
</div>

<center><img src= "1529602317389.jpg" alt="Centered Image"></center> 


<section div class="mary">Figure 17.10 Types of
component composition</section> </div>

<div class="sample1"><p>which combines their functionality. The ‘provides’ interface and ‘requires’ interface of the new component is a combination of the corresponding interfaces in
components A and B. The components are called separately through the external
interface of the composed component. A and B are not dependent and do not call
each other. This type of composition may be used with components that are program units or components that are services.</p>
<p>You might use all the forms of component composition when creating a system.
In all cases, you may have to write ‘glue code’ that links the components. For example, for sequential composition, the output of component A typically becomes the
input to component B. You need intermediate statements that call component A, collect the result, and then call component B with that result as a parameter. When one
component calls another, you may need to introduce an intermediate component that
ensures that the ‘provides’ interface and the ‘requires’ interface are compatible.
When you write new components especially for composition, you should design the
interfaces of these components so that they are compatible with other components in the
system. You can therefore easily compose these components into a single unit.
However, when components are developed independently for reuse, you will often be
faced with interface incompatibilities. This means that the interfaces of the components
that you wish to compose are not the same. Three types of incompatibility can occur:</p>
<p>1. Parameter incompatibility The operations on each side of the interface have the
same name but their parameter types or the number of parameters are different.</p>
<p>2.  Operation incompatibility The names  </p>
<p>3. Operation incompleteness The ‘provides’ interface of a component is a subset
of the ‘requires’ interface of another component or vice versa.</p>
<p>In all cases, you tackle the problem of incompatibility by writing an adaptor that
reconciles the interfaces of the two components being reused. An adaptor component
converts one interface to another. The precise form of the adaptor depends on the type</p></div>

<center><img src= "Screenshot 2025-09-03 093836.png" alt="Centered Image"></center>

<section div class="mary2">Figure 17.11Components with incompatible interfaces</section></div>

<div class="sample2"> of composition. Sometimes, as in the next example, the adaptor takes a result from one
component and converts it into a form where it can be used as an input to another. In
other cases, the adaptor may be called by component A as a proxy for component B.
This situation occurs if A wishes to call B but the details of the ‘requires’ interface of
A do not match the details of the ‘provides’ interface of B. The adaptor reconciles
these differences by converting its input parameters from A into the required input
parameters for B. It then calls B to deliver the services required by A.</p>
<p>To illustrate adaptors, consider the two components shown in Figure 17.11,
whose interfaces are incompatible. These might be part of a system used by the
emergency services. When the emergency operator takes a call, the phone number
is input to the addressFinder component to locate the address. Then, using the
mapper component, the operator prints a map to be sent to the vehicle dispatched
to the emergency. In fact, the components would have more complex interfaces
than those shown here, but the simplified version illustrates the concept of an
adaptor.</p>
<p>The first component, addressFinder, finds the address that matches a phone number. It can also return the owner of the property associated with the phone number and
the type of property. The mapper component takes a post code (in the United States,
a standard ZIP code with the additional four digits identifying property location) and
displays or prints a street map of the area around that code at a specified scale.</p>
<p>These components are composable in principle because the property location
includes the post or ZIP code. However, you have to write an adaptor component
called postCodeStripper that takes the location data from addressFinder and
strips out the post code. This post code is then used as an input to mapper and the
street map is displayed at a scale of 1:10,000. The following code, which is an
example of sequential composition, illustrates the sequence of calls that is required
to implement this:</p>
<p>address = addressFinder.location (phonenumber) ;
postCode = postCodeStripper.getPostCode (address) ;
mapper.displayMap(postCode, 10000) ;</p> 
</div>

<center><img src= "Screenshot 2025-09-03 095556.png" alt="Centered Image"></center>

<section div class="mary3"> Figure 17.12 Anadaptor linking a datacollector and a sensor</section> </div>

<div class="sample3"> Another case in which an adaptor component may be used is in hierarchical composition, where one component wishes to make use of another but there is an incompatibility between the ‘provides’ interface and ‘requires’ interface of the components
in the composition. I have illustrated the use of an adaptor in Figure 17.12 where an
adaptor is used to link a data collector and a sensor component. These could be used
in the implementation of a wilderness weather station system, as discussed in
Chapter 7.</p>
<p>The sensor and data collector components are composed using an adapter that
reconciles the ‘requires’ interface of the data collection component with the
‘provides’ interface of the sensor component. The data collector component has
been designed with a generic ‘requires’ interface that supports sensor data
collection and sensor management. For each of these operations, the parameter
is a text string representing the specific sensor commands. For example, to issue
a collect command, you would say <b>sensorData</b>(“collect”). As I have shown in
Figure 17.12, the sensor itself has separate operations such as start, stop, and
getdata.</p>
<p>The adaptor parses the input string, identifies the command (e.g., collect) and
then calls <b>ensor.getdata </b>Sto collect the sensor value. It then returns the result (as a
character string) to the <b>data collector </b>component. This interface style means that the
data collector can interact with different types of sensor. A separate adaptor, which
converts the sensor commands from Data collector to the actual sensor interface, is
implemented for each type of sensor.</p>
<p>The above discussion of component composition assumes you can tell from
the component documentation whether or not interfaces are compatible. Of
course, the interface definition includes the operation name and parameter types,
so you can make some assessment of the compatibility from this. However, you
depend on the component documentation to decide whether the interfaces are
semantically compatible.</p>
<p>To illustrate this problem, consider the composition shown in Figure 17.13. These
components are used to implement a system that downloads images from a digital
camera and stores them in a photograph library. The system user can provide
additional information to describe and catalog the photograph. To avoid clutter. </p></div>

<center><img src= "SScreenshot 2025-09-03 100240.png" alt="Centered Image"></center>

<div class="sample4"> I have not shown all interface methods here. Rather, I simply show the methods that
are needed to illustrate the component documentation problem. The methods in the
interface of Photo Library are:</p>
<ol>public void addItem (Identifier pid ; Photograph p; CatalogEntry
photodesc) ;
public Photograph retrieve (Identifier pid) ;
public CatalogEntry catEntry (Identifier pid);</ol>

<ol>Assume that the documentation for the addItem method in Photo Library is:</ol>
<ol>This method adds a photograph to the library and associates the photograph
identifier and catalogue descriptor with the photograph.</ol>
<ol>This description appears to explain what the component does, but consider the
following questions:</ol>
<li>What happens if the photograph identifier is already associated with a photograph
in the library?</li>
<li>Is the photograph descriptor associated with the catalog entry as well as the photograph? That is, if you delete the photograph, do you also delete the catalog
information?</li>
<p>  There is not enough information in the informal description of addItem to answer
these questions. Of course, it is possible to add more information to the natural language description of the method, but in general, the best way to resolve ambiguities
is to use a formal language to describe the interface. The specification shown in
Figure 17.14 is part of the description of the interface of<b>Photo Library </b> that adds
information to the informal description.</p>
<p>   The specification in Figure 17.14 uses pre- and post-conditions that are defined in
a notation based on the object constraint language (OCL), which is part of the UML
(Warmer and Kleppe, 2003). OCL is designed to describe constraints in UML object
models; it allows you to express predicates that must always be true, that must be</p></div>


<center><img src= "Screenshot 2025-09-03 100838.png" alt="Centered Images"></center>

<section div class="mary4"> Figure 17.14 The OCL description of the Photo Library interface</section></div>


<div class="sample5">true before a method has executed; and that must be true after a method has executed. These are invariants, pre-conditions, and post-conditions. To access the value
of a variable before an operation, you add @pre after its name. Therefore, using age
as an example:</p>
<p>age = age@pre + 1</p>
     <p>This statement means that the value of age after an operation is one more than it
was before that operation.</p>
    <p>OCL-based approaches are increasingly used to add semantic information to UML
models, and OCL descriptions may be used to drive code generators in model-driven
engineering. The general approach has been derived from Meyer’s Design by
Contract approach (Meyer, 1992), in which the interfaces and obligations of communicating objects are formally specified and enforced by the run-time system. Meyer
suggests that using Design by Contract is essential if we are to develop trusted components (Meyer, 2003).</p>
<p>Figure 17.14 includes a specification for the addItem and delete methods in
Photo Library. The method being specified is indicated by the keyword context and
the pre- and post-conditions by the keywords pre and post. The pre-conditions for
addItem state that:</p>
<p>1. There must not be a photograph in the library with the same identifier as the
photograph to be entered.
</p>
<p>2. The library must exist—assume that creating a library adds a single item to it so
that the size of a library is always greater than zero.</p>
<p>3. The post-conditions for addItem state that:</p>
<p>The size of the library has increased by 1 (so only a single entry has been made).</p>
<p>If you retrieve using the same identifier, then you get back the photograph
that you added.</p>
<p>If you look up the catalogue using that identifier, you get back the catalogue
entry that you made.</p>

<p>The specification of delete provides further information. The pre-condition states
that to delete an item, it must be in the library and, after deletion, the photo can no
longer be retrieved and the size of the library is reduced by 1. However, delete does
not delete the catalogue entry—you can still retrieve it after the photo has been
deleted. The reason for this is that you may wish to maintain information in the catalog about why a photo was deleted, its new location, and so on.</p>
<p>When you create a system by composing components, you may find that there are
potential conflicts between functional and non-functional requirements, the need to
deliver a system as quickly as possible and the need to create a system that can
evolve as requirements change. The decisions where you may have to take trade-offs
into account are:</p>
<p>1. What composition of components is most effective for delivering the functional
requirements for the system?</p>
<p>2. What composition of the components will make it easier to adapt the composite
component when its requirements change?</p>
<p>3. What will be the emergent properties of the composed system? These are properties such as performance and dependability. You can only assess these once
the complete system is implemented.</p>
<p>Unfortunately, there are many situations where the solutions to the composition
problems may conflict. For example, consider a situation such as that illustrated in
Figure 17.15, where a system can be created through two alternative compositions.
The system is a data collection and reporting system where data is collected from
different sources, stored in a database and then different reports summarizing that
data are produced.</p>
<p>Here, there is a potential conflict between adaptability and performance.
Composition (a) is more adaptable but composition (b) is perhaps faster and more
reliable. The advantages of composition (a) are that reporting and data management
are separate, so there is more flexibility for future change. The data management
system could be replaced and, if reports are required that the current reporting component cannot produce, that component can also be replaced without having to
change the data management component.</p>
<p>In composition (b), a database component with built-in reporting facilities (e.g.,
Microsoft Access) is used. The key advantage of composition (b) is that there are fewer
components, so this will be a faster implementation because there are no component</p> </div>

<section div class="mary5"> Figure 17.15 Data collection and report generation components</section></div>

<center><img src= "Screenshot 2025-09-03 101739.png" alt="Centered Images"></center>

<div class="sample6">communication overheads. Furthermore, data integrity rules that apply to the database
will also apply to reports. These reports will not be able to combine data in incorrect
ways. In composition (a), there are no such constraints so errors in reports could occur.</p>
<p>In general, a good composition principle to follow is the principle of separation of
concerns. That is, you should try to design your system in such a way that each component has a clearly defined role and that, ideally, these roles should not overlap.
However, it may be cheaper to buy one multi-functional component rather than two
or three separate components. Furthermore, there may be dependability or performance penalties when multiple components are used.</p></div>










<footer> 
    <h1> R E F E R E N C E S</h1>
    
     <p>Mili, H., Mili, A., Yacoub, S. and Addy, E. (2002). Reuse-based Software Engineering. New York: John
      Wiley & Sons.</p>
     <p>Pope, A. (1997). The CORBA Reference Guide: Understanding the Common Object Request Broker
      Architecture. Harlow, UK: Addison-Wesley.</p>
     <p>Szyperski, C. (2002). Component Software: Beyond Object-oriented Programming, 2nd ed. Harlow,
     UK: Addison-Wesley.Szyperski, C. (2002). Component Software: Beyond Object-oriented Programming, 2nd ed. Harlow,
     UK: Addison-Wesley.</p>
     <p>Warmer, J. and Kleppe, A. (2003). The Object Constraint Language: Getting your models ready for
     MDA. Boston: Addison-Wesley.</p>
     <p>Weinreich, R. and Sametinger, J. (2001). ‘Component Models and Component Services: Concepts and
     Principles’. In Component-Based Software Engineering. Heineman, G. T. and Councill, W. T. (ed.).
     Boston: Addison-Wesley, 33–48.</p>
</footer>













    



    



</body>
</html>